#pragma once
#include "Import.hpp"
#include "ModelConfig.hpp"
#include "../RDF_parser/progress_bar.hpp"

class DataModel
{
public:
	vector<pair<pair<unsigned int, unsigned int>, unsigned int>> data_train;
	vector<pair<pair<unsigned int, unsigned int>, unsigned int>> data_test_true;
	vector<vector<pair<pair<unsigned int, unsigned int>, unsigned int>> *> data_train_false;

public:
	size_t entity_size;
	size_t relation_size;

public:
	vector<char> relation_type;

public:
	DataModel(const Dataset *dataset, bool do_load_testing, size_t entity_size, size_t relation_size) : entity_size(entity_size), relation_size(relation_size)
	{
		if (!do_load_testing)
		{
			std::cout << dataset->name << " start loading training ... " << std::endl;
			load_training(dataset->base_dir + dataset->training, 4);
			std::cout << dataset->name << " start loading training false ... " << std::endl;
			load_training_false(dataset->base_dir, dataset->training_false);
			std::cout << dataset->name << " start loading relation type ... " << std::endl;
			load_relation_type(dataset->base_dir + dataset->rel_type);
		}

		if (do_load_testing)
		{
			load_testing(dataset->base_dir + dataset->testing, data_test_true);
			std::cout << dataset->name << " start loading relation type ... " << std::endl;
			load_relation_type(dataset->base_dir + dataset->rel_type);
		}
		std::cout << dataset->name << " finish loading " << std::endl;
	}

	/**
	 * @brief Load the training dataset into memory. The dataset needs to be a binary file. It 
	 * starts with the total number
	 * of triples it contains, followed with each head-relation-tail triples expressed in three 
	 * unsigned int. The dataset generated by RDF_parser can be directly loaded by this method. 
	 * 
	 * @param file_path : File path to triple data file
	 * 
	 */

	void load_training(const string &file_path, int num_stream)
	{
		ifstream triple_file(file_path, ios_base::binary);

		size_t triple_size;
		triple_file.read((char *)&triple_size, sizeof(size_t));
		data_train.reserve(triple_size);
		for (unsigned int i = 0; i < triple_size && triple_file; ++i)
		{

			unsigned int tri_arr[3];
			triple_file.read((char *)tri_arr, sizeof(unsigned int) * 3);

			data_train.push_back(make_pair(make_pair(tri_arr[0], tri_arr[2]), tri_arr[1]));
		}
		triple_file.close();
		std::cout << "Finish reading " << file_path << std::endl;
	}

	void
	load_training_false(const string &base_dir, const vector<string> &training_false)
	{
		vector<ifstream *> streams;
		for (auto i : training_false)
		{
			streams.push_back(new ifstream(base_dir + i, ios_base::binary));
		}
		size_t size;
		unsigned int triple[3];
		for (auto i : streams)
		{
			i->read((char *)&size, sizeof(size));
			auto this_vector = new vector<pair<pair<unsigned int, unsigned int>, unsigned int>>();
			this_vector->reserve(size);
			data_train_false.push_back(this_vector);
			for (size_t j = 0; j < size; ++j)
			{
				i->read((char *)triple, sizeof(unsigned int) * 3);
				auto pr = make_pair(make_pair(triple[0], triple[2]), triple[1]);
				this_vector->push_back(pr);
			}
		}
		for (auto i : streams)
		{
			i->close();
		}
	}

	void load_relation_type(const string &path)
	{
		ifstream file(path, ios::binary);
		if (file.is_open())
		{
			cout << path << " relation type open sucessfully" << endl;
		}
		auto size = relation_type.size();
		file.read((char *)&size, sizeof(size));
		relation_type.reserve(size);
		char t;
		for (size_t i = 0; i < size; ++i)
		{
			file.read((char *)&t, sizeof(t));
			relation_type.push_back(t);
		}
		file.close();
	}

	void load_testing(const string &file_path,
					  vector<pair<pair<unsigned int, unsigned int>, unsigned int>> &vin_true)
	{
		ifstream triple_file(file_path, ios_base::binary);

		size_t triple_size;
		triple_file.read((char *)&triple_size, sizeof(size_t));
		ProgressBar prog_bar("Deserializing binary file to triples:", triple_size);
		prog_bar.progress_begin();

		for (prog_bar.progress = 0; prog_bar.progress < triple_size && triple_file; ++prog_bar.progress)
		{

			unsigned int tri_arr[3];
			triple_file.read((char *)tri_arr, sizeof(unsigned int) * 3);

			vin_true.push_back(make_pair(make_pair(tri_arr[0], tri_arr[2]), tri_arr[1]));
		}
		triple_file.close();
		prog_bar.progress_end();

		if (prog_bar.progress != triple_size)
		{
			cerr << "triple_deserialize: Something wrong in binary file reading. " << endl;
		}
	}

	pair<pair<unsigned int, unsigned int>, unsigned int> *sample_false_triplet(size_t index) const
	{
		size_t false_size = data_train_false.size();
		size_t false_index = rand() % false_size;
		return &(*data_train_false[false_index])[index];
	}

	~DataModel()
	{
		for (auto i : data_train_false)
		{
			delete i;
		}
	}
};